# The pbbeacon language

This is not a very complete overview of the scripting language. I apologize for the brevity.

## Syntax

A `pbbeacon` script is made of values and operators. The only types are *number* and *color*.

Numeric literals are just decimal numbers: `4` or `3.1416`. Because of the underlying [Pixelblaze language][pblang], numbers are always handled as signed fixed-point 15.16 values.

[pblang]: https://electromage.com/docs/language-reference

Color literals are hex values, like in HTML, only with a dollar sign: `$FFF` or `$336699`. Internally a color is a trio of fixed-point numbers, 0.0 to 1.0.

An operator is a name with its arguments indented under it:

```
clamp
  min=0.3
  max=0.7
  arg=wave
    shape=sine
    period=0.5
```

You can often leave the arguments unnamed, especially if they all behave similarly:

```
sum
  1
  2
  3
```

For brevity, you can collapse the arguments onto a single line after a colon. You can even use the shorthand (colon) format and the explicit (indented) format for the same operator! This is where the syntax gets confusing. Sorry about that.

```
clamp: min=0.3, max=0.7
  wave: sine, period=0.5
```

You can define a value or function at the top level, and then use its name as a variable:

```
foo=3
bar=wave: sine

sum
  foo
  bar
```

Lines starting with `#` are comments. (That's why I had to use `$` for colors.)

## Base cases

The point of a script is to generate a color value. This means that this is a valid script:

```
# Solid red strip
$F00
```

Numbers are "upcast" to greyscale values, which means that a plain number is *also* a valid script:

```
# Solid 50% grey strip
0.5
```

But we really want want patterns that vary in time and space, right? This is a wave in space:

```
wave
  shape=sine
```

`wave` produces a number from 0 to 1. So this pattern is black at the ends and white in the middle.

What about a sine wave that varies in time? 

```
time
  wave
    shape=sine
```

This produces a flat greyscale color that shifts from black to white to black every second.

The `wave` operator and a couple of others can generate variation in either space or time. The defaults attempt to be sensible, but you can always adjust them by putting the entire operator under a `space` or `time` block.

## Time, space, and color

Note that the idea of *pixel count* is completely abstracted away. `pbbeacon` runs on a virtually continuous LED strip whose coordinates run from 0 to 1. Similarly, it abstracts away the update frame rate; time is always measured in seconds.

`pbbeacon` works in a linear color-space. That is, it assumes that value 0.5 is half the brightness of value 1.0. This is also true of the underlying Pixelblaze language.

Real LED strips are not linear at all. A raw 0.5 value is much closer to 1.0 than to 0.0. To compensate for this, the code generated by `pbbeacon` applies a crude "N-squared" modifier to all values just before output. (This is literally the last line of every compiled pattern in the [scripts](./scripts) directory.) This N-squared tactic is very common in the Pixelblaze community. If the hardware ever supports something more precise, I'll adopt it.

## Operators

Each operator is listed with its named arguments. If you provide arguments without names, they are applied sequentially.

**constant** 

- `value`=_number_

Simple numeric constant. This is equivalent to just writing the _number_ on its own.

**color** 

- `value`=_color_

Simple color constant. This is equivalent to just writing the _color_ on its own.

**rgb**

- `r`
- `g`
- `b`

Composes three numeric values into a color.

You might say "why not use use a color constant?" Remember, each of `r`, `g`, and `b` can be a *function*.

**brightness**

- `value`

Turns a color value into a numeric brightness from 0 to 1.

(Actually, you can make an "improper" color value whose components are outside the 0-1 range. In those cases, `brightness` can be any number.)

**time**

- `arg`

Constrains its argument to operate over time. It's most commonly applied to `wave`. Other operators which operate over an axis are `linear`, `randflat`, and `randnorm`.

The default axis for top-level operators is `space`. When an operator like `wave` is used as a parameter, the default varies. This tries to behave sensibly but the result can be counterintuitive. Use the `time` operator (or `space`, below) to change the default.

You can also use `time` or `space` on certain compound operations like `sum: wave, wave, ...`. The axial constraint will descend to inner operators.

**space**

- `arg`

Constrains its argument to operate over space. See above.

**linear**

- `start`
- `velocity`
- (operates on the `time` or `space` axis)

Generates a linearly changing value: `s+vx` or `s+vt`, depending on whether it applies to `space` or `time`.

**changing**

- `start`
- `velocity`

Generates a value that changes over time. (This cannot operate over `space`.) This is a lot like `linear`, but if the `velocity` is non-constant, the value will be the cumulative total rather than a simple `s+vt`. Mathematically, this approximates the integral of `velocity`.

*Bug alert:* Do not use `changing` as a `pulser` argument. It does not properly distinguish between different pulses. You will get garbage results, probably flying off-strip. Yes, I know, this makes `changing` mostly useless.

**randflat**

- `min`
- `max`
- (operates on the `time` or `space` axis)

Generates a random value between `min` and `max`. The value has nothing to do with `x` or `t`; the axis just determines whether it varies over `space` or `time`.

**randnorm**

- `mean`=0.5
- `stdev`=0.25
- (operates on the `time` or `space` axis)

Generates a random value that clusters around `mean`. With the default values, the result will be between 0.25 and 0.75 about 68% of the time. It will be between 0.0 and 1.0 about 95% of the time.

(This is an approximation, not a true normal distribution. In fact the value will never be more than 2.88 `stdev` from `mean`.)

**clamp**

- `arg`
- `min`=0
- `max`=1

Generates the `arg`, unless that is less than `min` or greater than `max`.

**lerp**

- `arg1`
- `arg2`
- `weight`

Generates the value `arg1` if `weight` is 0, `arg2` if `weight` is 1, or a value between those if `weight` is between 0 and 1. If `weight` is less than 0 or greater than 1, the value is extended linearly.

**sum**

- `arg`, `arg`, `arg`...

Adds its arguments. There may be any number of arguments.

If you add colors, they are added componentwise (`r1+r2`, `g1+g2`, `b1+b2`).

**mean**

- `arg`, `arg`, `arg`...

Averages its arguments.

**mul**

- `arg`, `arg`, `arg`...

Multiplies its arguments.

The easiest way to turn a number into a color is to multiply it by the color value.

**max**

- `arg`, `arg`, `arg`...

Finds the highest value of any of its arguments. If this is applied to colors, the maximum is computed componentwise (separately for red, green, and blue).

**min**

- `arg`, `arg`, `arg`...

Finds the lowest value of any of its arguments.

**decay**

- `halflife`=_number_
- `arg`

Generates a value based on `arg`, except that whenever `arg` drops, the generated value decays *slowly* towards zero rather than dropping immediately. The `halflife` is how many seconds it takes to get halfway to zero.

(This doesn't support decaying *up*. If `arg` goes negative, its values are ignored.)

**gradient**

- `stop`, `stop`, `stop`...
- `arg`

Uses the `stop`s as a gradient table for the `arg` value.

The format for this is:

```
gradient
  stop: 0.00, $000
  stop: 0.33, $900
  stop: 0.50, $D20
  stop: 0.66, $EA0
  stop: 1.00, $EEF
  arg
```

There can be any number of stops, and they don't have to be evenly distributed. The values have to be constants. Colors in between stops are linearly interpolated.

You will usually provide stops from 0 to 1, but this is not a requirement. Values outside the stop range stick to the first or last color value.

**wave**

- `shape`=_waveshape_
- `min`=0
- `max`=1
- `period`=1
- `shift`=0
- (operates on the `time` or `space` axis)

Generates a continuous wave. The `shape` of the wave must be one of these constants: `flat`, `square`, `halfsquare`, `triangle`, `sine`, `trapezoid`, `sawtooth`, `sqrtooth`, `sawdecay`, `sqrdecay`.

`flat` is a constant value pegged at `max`. For tedious reasons, `square` is *also* a constant value pegged at `max`. Use `halfsquare` if you want a wave that bangs up and down from `min` to `max` at even intervals.

If operating in `space`, the wave repeats forever in both directions. Its center is at 0.5, or 0.5+`shift` if `shift` is nonzero.

If operating in `time`, the wave starts at time 0 (or `shift`) and repeats forever.

**noise**

- `shift`=0
- `morph`=0
- `grain`=16
- `octaves`=1

Generates Perlin noise. This is a random value that wobbles smoothly along the length of the strip. The `shift` will move it; the `morph` will cause it to change in place. Or you can do both. The noise will wrap smoothly in any case.

The `grain` value defines how many wobbles there are. Use integers (2 to 256). The `octaves` (1 to maybe 4 or 5) will put smaller fractal wibbles on the wobbles.

*Bug alert:* If you have more than one `noise` operator in your pattern, they must all have the same `grain` value. If you try to make them different, only the first `grain` value will be used. This is a limitation of the underlying Pixelblaze `perlinTurbulence()` implementation.

**quote**

- `arg`

This does nothing on its own; it only has meaning within an argument of `pulser`. See below.

**pulser**

- `maxcount`=_integer_
- `spaceshape`=`triangle`
- `timeshape`=`sqrdecay`
- `interval`=1
- `pos`=0.5
- `duration`=1
- `width`=1

The big wahoonie! Really, I implemented all the other operators to support this one.

`pulser` generates a *sequence* of pulses with extremely flexible parameters. They can move, change size, stick around or fade away.

A pulse has a wave-shape, but it's only a single "bump". It does not repeat spatially forever like the `wave` operator.

The pulser will generate a pulse every `interval` seconds. (Unless there are too many! See below.)

The `spaceshape` specifies the pulse's shape in _space_. The `width` is the total width of this shape. But if `spaceshape` is `flat`, then the "pulse" is a constant value across all of space, and `width` is ignored.

The `timeshape` specifies the pulse's shape in _time_, from the moment of its creation. The `duration` is the total duration. But if `timeshape` is `flat`, then the pulse is immortal and `duration` is ignored.

(However, if a pulse moves monotonically, it expires when it moves out of sight.)

So a `pulser` with the default values above will generate one pulse per second. This will have a triangular profile from x=0 to x=1 -- the whole strip -- with its highest peak in the center. The pulse will start strong but decay to zero over its one-second lifespan. Since the `duration` equals the `interval`, there will be just one pulse at a time.

Now consider this example:

```
pulser:
  maxcount=3
  interval=0.2
  timeshape=sine
  duration=0.5
  width=0.1
  pos=linear
    start=0
    velocity=1
```

This generates pulses with a lifespan of 0.5 seconds. The `timeshape` is `sine`, so they will start small, increase smoothly to maximum value, and then decrease and vanish. Since a pulse will appear every 0.2 seconds and last 0.5 seconds, there can be up to 3 alive at a time.

The `spaceshape` is still `triangle` (the default value) but the `width` is now only 0.1. And the `pos` is given as a linearly increasing function. The first pulse will appear (with its center at) x=0. The second one, 0.2 seconds later, will be at x=0.2. The third at x=0.4, and so forth.

...Wait. That doesn't seem right. The sixth pulse will be at x=1.0. All pulses after that will be invisible, off-strip to the right! And since pulses have a lifespan, the pattern will be completely dark after time t=1.5.

This is legal code, but it's not what we meant. We want *each pulse* to have a linearly increasing position, starting at zero and zooming across the strip. 

To specify this, we use the mysterious `quote` operator:

```
pulser:
  maxcount=10
  interval=0.2
  timeshape=sine
  duration=0.5
  width=0.1
  pos=quote
    linear
      start=0
      velocity=1
```

Rather than each pulse getting a `pos` value *computed by* `linear: 0, 1`, each pulse gets a `pos` value which is the *function* `linear: 0, 1`.

...Yeah, that's still pretty confusing. Another way to think of it is that regular operators are *eager*; `quote`d operators are *lazy*. Or: regular operators belong to the *pulser*; `quote`d operators belong to the *pulse*.

Or just mess around with it and see how it works.

By the way, if you try this most recent example, you'll discover another problem. Since the pulses move with `velocity=1` but have `duration=0.5`, each one only gets halfway across the strip before expiring. The right side of the strip stays dark.

To fix this, you could set `duration=1` or `timeshape=flat`. Remember, `timeshape=flat` means infinite duration. (But the pulse will expire when it moves off-strip.)

`pulser` has some limitations:

- Pulses have no color. The value generated by `pulser` is a number, not a color. Run it through `gradient` or `mul: $ABC` to convert it to a color.

- All pulses have the same height: 1. If you want different amplitudes, use `mul`.

- Because Pixelblaze does not support dynamic allocation, you must specify the maximum number of pulses in advance. The `maxcount` is the maximum number of pulses that may exist at a time. If `interval` passes and there is no room for another pulse, no more will be generated until one expires.

(Again, pulses expire when their `duration` is over, or if they move outside the spatial range 0-1.)

(It's best to be generous when specifying `maxcount`. It wastes memory, but only a few bytes per, and the Pixelblaze has quite a bit of RAM.)

