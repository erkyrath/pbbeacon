# The pbbeacon language

This is not a very complete overview of the scripting language. I apologize for the brevity.

## Syntax

A `pbbeacon` script is made of values and operators. The only types are *number* and *color*.

Numeric literals are just decimal numbers: `4` or `3.1416`. Because of the underlying [Pixelblaze language][pblang], numbers are always handled as signed fixed-point 15.16 values.

[pblang]: https://electromage.com/docs/language-reference

Color literals are hex values, like in HTML, only with a dollar sign: `$FFF` or `$336699`. Internally a color is a trio of fixed-point numbers, 0.0 to 1.0.

An operator is a name with its arguments indented under it:

```
clamp
  min=0.3
  max=0.7
  arg=wave
    shape=sine
    period=0.5
```

You can often leave the arguments unnamed, especially if they all behave similarly:

```
sum
  1
  2
  3
```

For brevity, you can collapse the arguments onto a single line after a colon. You can even use the shorthand (colon) format and the explicit (indented) format for the same operator! This is where the syntax gets confusing. Sorry about that.

```
clamp: min=0.3, max=0.7
  wave: sine, period=0.5
```

You can define a value or function at the top level, and then use its name as a variable:

```
foo = 3
bar = wave: sine

sum
  foo
  bar
```

Lines starting with `#` are comments. (That's why I had to use `$` for colors.)

## Base cases

The point of a script is to generate a color value. This means that this is a valid script:

```
# Solid red strip
$F00
```

Numbers are "upcast" to greyscale values, which means that a plain number is *also* a valid script:

```
# Solid 50% grey strip
0.5
```

But we really want want patterns that vary in time and space, right? This is wave in space:

```
wave
  shape=sine
```

`wave` produces a number from 0 to 1. So this pattern is black at the ends and white in the middle.

What about a sine wave that varies in time? 

```
time
  wave
    shape=sine
```

This produces a flat greyscale color that shifts from black to white to black every second.

The `wave` operator and a couple of others can generate variation in either space or time. The defaults attempt to be sensible, but you can always adjust them by putting the entire operator under a `space` or `time` block.

## Time, space, and color

Note that the idea of *pixel count* is completely abstracted away. `pbbeacon` runs on a virtually continuous LED strip whose coordinates run from 0 to 1. Similarly, it abstracts away the update frame rate; time is always measured in seconds.

`pbbeacon` works in a linear color-space. That is, it assumes that value 0.5 is half the brightness of value 1.0. This is also true of the underlying Pixelblaze language.

Real LED strips are not linear at all. A raw 0.5 value is much closer to 1.0 than to 0.0. To compensate for this, the code generated by `pbbeacon` applies a crude "N-squared" modifier to all values just before output. (This is literally the last line of every compiled pattern in the [scripts](./scripts) directory.) This N-squared tactic is very common in the Pixelblaze community. If the hardware ever supports something more precise, I'll adopt it.

## Operators

Each operator is listed with its named arguments. If you provide arguments without names, they are applied sequentially.

**constant** 

- `value`=_number_

Simple numeric constant. This is equivalent to just writing the _number_ on its own.

**color** 

- `value`=_color_

Simple color constant. This is equivalent to just writing the _color_ on its own.

**rgb**

- `r`
- `g`
- `b`

Composes three numeric values into a color.

You might say "why not use use a color constant?" Remember, each of `r`, `g`, and `b` can be a *function*.

**brightness**

- `value`

Turns a color value into a numeric brightness from 0 to 1.

(Actually, you can make an "improper" color value whose components are outside the 0-1 range. In those cases, `brightness` can be any number.)

**time**

- `arg`

Constrains its argument to operate over time. It's most commonly applied to `wave`. Other operators which operate over an axis are `linear`, `randflat`, and `randnorm`.

The default axis for top-level operators is `space`. When an operator like `wave` is used as a parameter, the default varies. This tries to behave sensibly but the result can be counterintuitive. Use the `time` operator (or `space`, below) to change the default.

You can also use `time` or `space` on certain compound operations like `sum: wave, wave, ...`. The axial constraint will descend to inner operators.

**space**

- `arg`

Constrains its argument to operate over space. See above.

**linear**

- `start`
- `velocity`
- (operates on the `time` or `space` axis)

Generates a linearly changing value: `s+vx` or `s+vt`, depending on whether it applies to `space` or `time`.

**changing**

- `start`
- `velocity`

Generates a value that changes over time. (This cannot operate over `space`.) This is a lot like `linear`, but if the `velocity` is non-constant, the value will be the cumulative total rather than a simple `s+vt`. Mathematically, this approximates the integral of `velocity`.

*Bug alert:* Do not use `changing` as a `pulser` argument. It does not properly distinguish between different pulses; you will get garbage results, probably flying off-screen. I know, this makes `changing` mostly useless.

**randflat**

- `min`
- `max`
- (operates on the `time` or `space` axis)

Generates a random value between `min` and `max`. The value has nothing to do with `x` or `t`; the axis just determines whether it varies over `space` or `time`.

**randnorm**

- `mean`=0.5
- `stdev`=0.25
- (operates on the `time` or `space` axis)

Generates a random value that clusters around `mean`. With the default values, the result will be between 0.25 and 0.75 about 68% of the time. It will be between 0.0 and 1.0 about 95% of the time.

(This is an approximation, not a true normal distribution. In fact the value will never be more than 2.88 `stdev` from `mean`.)

**clamp**

- `arg`
- `min`=0
- `max`=1

Generates the `arg`, unless that is less than `min` or greater than `max`.

**lerp**

- `arg1`
- `arg2`
- `weight`

Generates the value `arg1` if `weight` is 0, `arg2` if `weight` is 1, or a value between those if `weight` is between 0 and 1. If `weight` is less than 0 or greater than 1, the value is extended linearly.

**sum**

- `arg`, `arg`, `arg`...

Adds its arguments. There may be any number of arguments.

If you add colors, they are added componentwise (`r1+r2`, `g1+g2`, `b1+b2`).

**mean**

- `arg`, `arg`, `arg`...

Averages its arguments.

**mul**

- `arg`, `arg`, `arg`...

Multiplies its arguments.

**max**

- `arg`, `arg`, `arg`...

Finds the highest value of any of its arguments. If this is applied to colors, the maximum is computed componentwise (separately for red, green, and blue).

**min**

- `arg`, `arg`, `arg`...

Finds the lowest value of any of its arguments.

**decay**

- `halflife`=_number_
- `arg`

Generates a value based on `arg`, except that whenever `arg` drops, the generated value decays *slowly* towards zero rather than dropping immediately. The `halflife` is how many seconds it takes to get halfway to zero.

(This doesn't support decaying *up*. If `arg` goes negative, its values are ignored.)

**gradient**

- `stop`, `stop`, `stop`...
- `arg`

Uses the `stop`s as a gradient table for the `arg` value.

The format for this is:

```
gradient
  stop: 0.00, $000
  stop: 0.33, $900
  stop: 0.50, $D20
  stop: 0.66, $EA0
  stop: 1.00, $EEF
  arg
```

There can be any number of stops, and they don't have to be evenly distributed. The values have to be constants. Colors in between stops are linearly interpolated.

You will usually provide stops from 0 to 1, but this is not a requirement. Values outside the stop range stick to the first or last color value.

**wave**

- `shape`
- `min`=0
- `max`=1
- `period`=1
- `shift`=0
- (operates on the `time` or `space` axis)

Generates a continuous wave. The `shape` of the wave must be one of these constants: `flat`, `square`, `halfsquare`, `triangle`, `sine`, `trapezoid`, `sawtooth`, `sqrtooth`, `sawdecay`, `sqrdecay`.

`flat` is a constant value pegged at `max`. For tedious reasons, `square` is *also* a constant value pegged at `max`. Use `halfsquare` if you want a wave that bangs up and down from `min` to `max` at even intervals.

If operating in `space`, the wave repeats forever in both directions. Its center is at 0.5, or 0.5+`shift` if `shift` is nonzero.

If operating in `time`, the wave starts at time 0 (or `shift`) and repeats forever.

**quote**

- `arg`

This does nothing on its own; it only has meaning within an argument of `pulser`. See below.

**pulser**

- `maxcount`=_integer_
- `spaceshape`=`triangle`
- `timeshape`=`sqrdecay`
- `interval`=1
- `pos`=0.5
- `duration`=1
- `width`=1

