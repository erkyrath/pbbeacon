/// sum:
///   gradient:
///     stop: 0, $300
///     stop: 1, $C00
///     time: wave: sine
///   gradient:
///     stop: 0, $033
///     stop: 1, $0C3
///     space: wave: sine

var clock = 0   // seconds

function evalGradient(val, posls, colls, count)
{
  if (val <= posls[0]) {
    return colls[0]
  }
  if (val >= posls[count-1]) {
    return colls[count-1]
  }
  for (var ix=0; ix<count-1; ix++) {
    if (val < posls[ix+1]) {
      return mix(colls[ix], colls[ix+1], (val-posls[ix])/(posls[ix+1]-posls[ix]))
    }
  }
  return colls[count-1]
}
var gradient_10_grad_pos = [0.0, 1.0]
var gradient_10_grad_r = [0.0, 0.0]
var gradient_10_grad_g = [0.2, 0.8]
var gradient_10_grad_b = [0.2, 0.2]
var gradient_1_grad_pos = [0.0, 1.0]
var gradient_1_grad_r = [0.2, 0.8]
var gradient_1_grad_g = [0.0, 0.0]
var gradient_1_grad_b = [0.0, 0.0]

var gradient_10_vector_r = array(pixelCount)
var gradient_10_vector_g = array(pixelCount)
var gradient_10_vector_b = array(pixelCount)
var gradient_1_scalar_r
var gradient_1_scalar_g
var gradient_1_scalar_b
var sum_0_vector_r = array(pixelCount)
var sum_0_vector_g = array(pixelCount)
var sum_0_vector_b = array(pixelCount)

for (var ix=0; ix<pixelCount; ix++) {
  var wave_14_val_min = 0  // for gradient_10
  var wave_14_val_hdiff = ((1-wave_14_val_min)*0.5)  // for gradient_10
  var wave_14_val_min = 0  // for gradient_10
  var wave_14_val_hdiff = ((1-wave_14_val_min)*0.5)  // for gradient_10
  var wave_14_val_min = 0  // for gradient_10
  var wave_14_val_hdiff = ((1-wave_14_val_min)*0.5)  // for gradient_10
  gradient_10_vector_r[ix] = (evalGradient((wave_14_val_min+wave_14_val_hdiff*(1-cos(PI2*(((ix/pixelCount)-0.5)/1+0.5)))), gradient_10_grad_pos, gradient_10_grad_r, 2))
  gradient_10_vector_g[ix] = (evalGradient((wave_14_val_min+wave_14_val_hdiff*(1-cos(PI2*(((ix/pixelCount)-0.5)/1+0.5)))), gradient_10_grad_pos, gradient_10_grad_g, 2))
  gradient_10_vector_b[ix] = (evalGradient((wave_14_val_min+wave_14_val_hdiff*(1-cos(PI2*(((ix/pixelCount)-0.5)/1+0.5)))), gradient_10_grad_pos, gradient_10_grad_b, 2))
}

export function beforeRender(delta) {
  clock += (delta / 1000)
  var wave_5_val_min = 0  // for gradient_1
  var wave_5_val_hdiff = ((1-wave_5_val_min)*0.5)  // for gradient_1
  var wave_5_val_min = 0  // for gradient_1
  var wave_5_val_hdiff = ((1-wave_5_val_min)*0.5)  // for gradient_1
  var wave_5_val_min = 0  // for gradient_1
  var wave_5_val_hdiff = ((1-wave_5_val_min)*0.5)  // for gradient_1
  gradient_1_scalar_r = (evalGradient((wave_5_val_min+wave_5_val_hdiff*(1-cos(PI2*clock/1))), gradient_1_grad_pos, gradient_1_grad_r, 2))
  gradient_1_scalar_g = (evalGradient((wave_5_val_min+wave_5_val_hdiff*(1-cos(PI2*clock/1))), gradient_1_grad_pos, gradient_1_grad_g, 2))
  gradient_1_scalar_b = (evalGradient((wave_5_val_min+wave_5_val_hdiff*(1-cos(PI2*clock/1))), gradient_1_grad_pos, gradient_1_grad_b, 2))
  for (var ix=0; ix<pixelCount; ix++) {
    sum_0_vector_r[ix] = ((gradient_1_scalar_r + gradient_10_vector_r[ix]))
    sum_0_vector_g[ix] = ((gradient_1_scalar_g + gradient_10_vector_g[ix]))
    sum_0_vector_b[ix] = ((gradient_1_scalar_b + gradient_10_vector_b[ix]))
  }
}

export function render(index) {
  var valr = sum_0_vector_r[index]
  var valg = sum_0_vector_g[index]
  var valb = sum_0_vector_b[index]
  rgb(valr*valr, valg*valg, valb*valb)
}

