/// gradient:
///   stop: 0, $000
///   stop: 0.25, $060
///   stop: 1.0, $FCF
///   mul:
///     wave: sine
///     time: wave: sine

var clock = 0   // seconds
function evalGradient(val, posls, colls, count)
{
  if (val <= posls[0]) {
    return colls[0]
  }
  if (val >= posls[count-1]) {
    return colls[count-1]
  }
  for (var ix=0; ix<count-1; ix++) {
    if (val < posls[ix+1]) {
      return mix(colls[ix], colls[ix+1], (val-posls[ix])/(posls[ix+1]-posls[ix]))
    }
  }
  return colls[count-1]
}
var gradient_0_grad_pos = [0.0, 0.25, 1.0]
var gradient_0_grad_r = [0.0, 0.0, 1.0]
var gradient_0_grad_g = [0.0, 0.4, 0.8]
var gradient_0_grad_b = [0.0, 0.0, 1.0]
var time_9_scalar
var wave_5_vector = array(pixelCount)
var gradient_0_vector_r = array(pixelCount)
var gradient_0_vector_g = array(pixelCount)
var gradient_0_vector_b = array(pixelCount)
for (var ix=0; ix<pixelCount; ix++) {
  var wave_5_val_min = 0  // for wave_5
  var wave_5_val_hdiff = ((1-wave_5_val_min)*0.5)  // for wave_5
  wave_5_vector[ix] = ((wave_5_val_min+wave_5_val_hdiff*(1-cos(PI2*(((ix/pixelCount)-0.5)/1+0.5)))))
}
export function beforeRender(delta) {
  clock += (delta / 1000)
  var wave_10_val_min = 0  // for time_9
  var wave_10_val_hdiff = ((1-wave_10_val_min)*0.5)  // for time_9
  time_9_scalar = ((wave_10_val_min+wave_10_val_hdiff*(1-cos(PI2*clock/1))))
  for (var ix=0; ix<pixelCount; ix++) {
    gradient_0_vector_r[ix] = (evalGradient((wave_5_vector[ix] * time_9_scalar), gradient_0_grad_pos, gradient_0_grad_r, 3))
    gradient_0_vector_g[ix] = (evalGradient((wave_5_vector[ix] * time_9_scalar), gradient_0_grad_pos, gradient_0_grad_g, 3))
    gradient_0_vector_b[ix] = (evalGradient((wave_5_vector[ix] * time_9_scalar), gradient_0_grad_pos, gradient_0_grad_b, 3))
  }
}
export function render(index) {
  var valr = gradient_0_vector_r[index]
  var valg = gradient_0_vector_g[index]
  var valb = gradient_0_vector_b[index]
  rgb(valr*valr, valg*valg, valb*valb)
}
